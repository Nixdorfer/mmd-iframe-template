<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>3D生存游戏</title>
	<style>
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
	user-select: none;
}

body {
	background: #242424;
	display: flex;
	justify-content: center;
	align-items: center;
	min-height: 100vh;
	font-family: system-ui, sans-serif;
	overflow: hidden;
}

#gameContainer {
	position: relative;
}

#gameCanvas {
	border: 2px solid #4a4a6a;
	border-radius: 4px;
}

#ui {
	position: absolute;
	top: 10px;
	left: 10px;
	color: white;
	pointer-events: none;
}

.stat-bar {
	width: 160px;
	height: 18px;
	background: #333;
	border-radius: 3px;
	margin: 4px 0;
	overflow: hidden;
	border: 1px solid #555;
	position: relative;
}

.stat-fill {
	height: 100%;
	transition: width 0.3s;
}

.stat-label {
	position: absolute;
	left: 6px;
	top: 50%;
	transform: translateY(-50%);
	font-size: 11px;
	text-shadow: 1px 1px 2px black;
	z-index: 1;
	display: flex;
	align-items: center;
	gap: 4px;
}

.stat-label svg {
	width: 12px;
	height: 12px;
}

#health .stat-fill {
	background: #c0392b;
}

#mana .stat-fill {
	background: #2980b9;
}

#exp .stat-fill {
	background: #8e44ad;
}

#rightButtons {
	position: absolute;
	top: 10px;
	right: 10px;
	display: flex;
	flex-direction: column;
	gap: 8px;
}

.side-btn {
	width: 44px;
	height: 44px;
	background: rgba(0, 0, 0, 0.7);
	border: 1px solid #666;
	border-radius: 6px;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: background 0.2s;
}

.side-btn:hover {
	background: rgba(60, 60, 60, 0.8);
}

.side-btn svg {
	width: 24px;
	height: 24px;
	stroke: #ccc;
	fill: none;
	stroke-width: 1.5;
}

#quickBar {
	position: absolute;
	bottom: 10px;
	left: 50%;
	transform: translateX(-50%);
	display: flex;
	gap: 4px;
}

.quick-slot {
	width: 48px;
	height: 48px;
	background: rgba(0, 0, 0, 0.7);
	border: 1px solid #555;
	border-radius: 6px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	color: white;
	font-size: 18px;
	position: relative;
}

.quick-slot.selected {
	border-color: #f1c40f;
	box-shadow: 0 0 8px #f1c40f;
}

.quick-slot .slot-count {
	font-size: 10px;
	position: absolute;
	bottom: 2px;
	right: 4px;
}

.quick-slot .slot-key {
	font-size: 9px;
	position: absolute;
	top: 2px;
	left: 4px;
	color: #888;
}

#inventoryPanel, #storagePanel {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background: rgba(30, 30, 30, 0.95);
	border: 2px solid #555;
	border-radius: 8px;
	padding: 16px;
	color: white;
	display: none;
	min-width: 320px;
}

.panel-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 12px;
	padding-bottom: 8px;
	border-bottom: 1px solid #444;
}

.panel-title {
	font-size: 16px;
	display: flex;
	align-items: center;
	gap: 8px;
}

.panel-title svg {
	width: 20px;
	height: 20px;
	stroke: #ccc;
	fill: none;
	stroke-width: 1.5;
}

.close-btn {
	width: 28px;
	height: 28px;
	background: transparent;
	border: 1px solid #666;
	border-radius: 4px;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
}

.close-btn:hover {
	background: #444;
}

.close-btn svg {
	width: 16px;
	height: 16px;
	stroke: #aaa;
	fill: none;
	stroke-width: 2;
}

.panel-grid {
	display: grid;
	grid-template-columns: repeat(6, 48px);
	gap: 4px;
}

.inv-slot {
	width: 48px;
	height: 48px;
	background: rgba(50, 50, 50, 0.8);
	border: 1px solid #444;
	border-radius: 4px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	color: white;
	font-size: 20px;
	cursor: pointer;
	position: relative;
}

.inv-slot:hover {
	border-color: #888;
}

.inv-slot .slot-count {
	font-size: 10px;
	position: absolute;
	bottom: 2px;
	right: 4px;
}

#timeDisplay {
	position: absolute;
	top: 10px;
	left: 50%;
	transform: translateX(-50%);
	color: white;
	font-size: 14px;
	text-shadow: 1px 1px 2px black;
	background: rgba(0, 0, 0, 0.5);
	padding: 4px 12px;
	border-radius: 4px;
}

#instructions {
	position: absolute;
	bottom: 70px;
	left: 10px;
	color: #666;
	font-size: 11px;
}

#levelDisplay {
	font-size: 12px;
	color: #aaa;
	margin-top: 4px;
}

.placeholder {
	width: 28px;
	height: 28px;
	background: #fff;
	border: 2px dashed #c00;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 8px;
	color: #c00;
	font-weight: bold;
}

.quick-slot .placeholder, .inv-slot .placeholder {
	width: 32px;
	height: 32px;
	font-size: 9px;
}
	</style>
</head>
<body>
	<div id="gameContainer">
		<canvas id="gameCanvas" width="960" height="640"></canvas>
		<div id="ui">
			<div id="health" class="stat-bar">
				<div class="stat-label">
					<svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" stroke="currentColor" fill="none"/></svg>
					<span>100/100</span>
				</div>
				<div class="stat-fill" style="width: 100%"></div>
			</div>
			<div id="mana" class="stat-bar">
				<div class="stat-label">
					<svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" stroke="currentColor" fill="none"/></svg>
					<span>100/100</span>
				</div>
				<div class="stat-fill" style="width: 100%"></div>
			</div>
			<div id="exp" class="stat-bar">
				<div class="stat-label">
					<svg viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" stroke="currentColor" fill="none"/></svg>
					<span>0/100</span>
				</div>
				<div class="stat-fill" style="width: 0%"></div>
			</div>
			<div id="levelDisplay">Lv.1</div>
		</div>
		<div id="timeDisplay">Day 1</div>
		<div id="rightButtons">
			<button class="side-btn" id="btnInventory" title="背包">
				<svg viewBox="0 0 24 24"><path d="M20 7h-4V4c0-1.1-.9-2-2-2h-4c-1.1 0-2 .9-2 2v3H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2zM10 4h4v3h-4V4z"/></svg>
			</button>
			<button class="side-btn" id="btnStorage" title="仓库">
				<svg viewBox="0 0 24 24"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>
			</button>
		</div>
		<div id="quickBar"></div>
		<div id="inventoryPanel">
			<div class="panel-header">
				<div class="panel-title">
					<svg viewBox="0 0 24 24"><path d="M20 7h-4V4c0-1.1-.9-2-2-2h-4c-1.1 0-2 .9-2 2v3H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2zM10 4h4v3h-4V4z"/></svg>
					背包
				</div>
				<button class="close-btn" id="closeInventory">
					<svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
				</button>
			</div>
			<div class="panel-grid" id="inventoryGrid"></div>
		</div>
		<div id="storagePanel">
			<div class="panel-header">
				<div class="panel-title">
					<svg viewBox="0 0 24 24"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>
					仓库
				</div>
				<button class="close-btn" id="closeStorage">
					<svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
				</button>
			</div>
			<div class="panel-grid" id="storageGrid"></div>
		</div>
		<div id="instructions">WASD移动 | 空格采集 | 1-6选择物品 | B背包 | V仓库</div>
	</div>
	<script>
const canvas = document.getElementById('gameCanvas')
const ctx = canvas.getContext('2d')
const TILE_W = 64
const TILE_H = 32
const WORLD_WIDTH = 30
const WORLD_HEIGHT = 30
const ITEMS = {
	wood: { name: '木材', label: 'WOOD', stackable: true },
	stone: { name: '石头', label: 'STONE', stackable: true },
	grass: { name: '草', label: 'GRASS', stackable: true },
	berry: { name: '浆果', label: 'BERRY', stackable: true, food: 10 },
	axe: { name: '斧头', label: 'AXE', stackable: false, tool: 'chop' },
	pickaxe: { name: '镐子', label: 'PICK', stackable: false, tool: 'mine' },
	sword: { name: '剑', label: 'SWORD', stackable: false, weapon: true, damage: 10 },
	gem: { name: '宝石', label: 'GEM', stackable: true }
}
const TERRAIN_COLORS = {
	'void': '#000000',
	'grass': '#4a7c23',
	'tall-grass': '#3d6b1a',
	'dirt': '#8b7355',
	'mud': '#5c4a3a',
	'swamp': '#4a5c3a',
	'sand': '#d4a574',
	'fine-sand': '#e8c9a0',
	'water': '#3498db',
	'swamp-water': '#2d5a4a',
	'sea': '#1a5276',
	'clay': '#a0522d',
	'stone-brick': '#808080',
	'concrete': '#a0a0a0',
	'asphalt': '#333333',
	'slate': '#606060'
}
const game = {
	camera: { x: 0, y: 0 },
	time: 0,
	day: 1,
	dayLength: 60000,
	entities: [],
	tiles: [],
	tileData: new Map(),
	mapBounds: { minX: 0, maxX: 29, minY: 0, maxY: 29 },
	keys: {},
	showInventory: false,
	showStorage: false
}
const player = {
	x: WORLD_WIDTH / 2,
	y: WORLD_HEIGHT / 2,
	z: 0,
	width: 32,
	height: 48,
	physWidth: 0.5,
	physDepth: 0.5,
	standingHeight: 1.75,
	crouchHeight: 1.0,
	currentHeight: 1.75,
	speed: 3,
	sprintMultiplier: 1.5,
	crouchMultiplier: 0.5,
	isCrouching: false,
	isSprinting: false,
	direction: 'down',
	frame: 0,
	frameTime: 0,
	isMoving: false,
	stats: { health: 100, maxHealth: 100, mana: 100, maxMana: 100, exp: 0, maxExp: 100, level: 1 },
	inventory: Array(24).fill(null),
	quickBar: Array(6).fill(null),
	selectedSlot: 0
}
const storage = { items: Array(24).fill(null) }
function worldToScreen(wx, wy) {
	const isoX = (wx - wy) * (TILE_W / 2)
	const isoY = (wx + wy) * (TILE_H / 2)
	return {
		x: isoX - game.camera.x + canvas.width / 2,
		y: isoY - game.camera.y + canvas.height / 2
	}
}
function screenToWorld(sx, sy) {
	const cx = sx - canvas.width / 2 + game.camera.x
	const cy = sy - 100 + game.camera.y
	return {
		x: (cx / (TILE_W / 2) + cy / (TILE_H / 2)) / 2,
		y: (cy / (TILE_H / 2) - cx / (TILE_W / 2)) / 2
	}
}
class Entity {
	constructor(x, y, type) {
		this.x = x
		this.y = y
		this.type = type
		this.health = this.getMaxHealth()
	}
	getMaxHealth() {
		switch(this.type) {
			case 'tree': return 10
			case 'rock': return 8
			case 'bush': return 3
			case 'grass': return 1
			case 'enemy': return 30
			default: return 5
		}
	}
	getDrops() {
		switch(this.type) {
			case 'tree': return [{ item: 'wood', count: 3 }]
			case 'rock': return [{ item: 'stone', count: 2 }, Math.random() < 0.1 ? { item: 'gem', count: 1 } : null].filter(Boolean)
			case 'bush': return [{ item: 'berry', count: 2 }]
			case 'grass': return [{ item: 'grass', count: 1 }]
			case 'enemy': return [{ item: 'gem', count: 1 }]
			default: return []
		}
	}
	getRequiredTool() {
		switch(this.type) {
			case 'tree': return 'chop'
			case 'rock': return 'mine'
			default: return null
		}
	}
	render(ctx) {
		const pos = worldToScreen(this.x, this.y)
		ctx.save()
		const labels = { tree: 'TREE', rock: 'ROCK', bush: 'BUSH', grass: 'GRASS', enemy: 'ENEMY' }
		const sizes = { tree: [40, 60], rock: [35, 30], bush: [30, 25], grass: [20, 15], enemy: [35, 45] }
		const label = labels[this.type] || '???'
		const [w, h] = sizes[this.type] || [30, 30]
		if (this.type === 'tree') {
			ctx.fillStyle = 'rgba(0,0,0,0.2)'
			ctx.beginPath()
			ctx.ellipse(pos.x, pos.y + 5, 20, 10, 0, 0, Math.PI * 2)
			ctx.fill()
		}
		drawPlaceholder(pos.x, pos.y, w, h, label)
		if (this.health < this.getMaxHealth()) {
			const healthPercent = this.health / this.getMaxHealth()
			ctx.fillStyle = '#333'
			ctx.fillRect(pos.x - 20, pos.y - h - 10, 40, 5)
			ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : '#e74c3c'
			ctx.fillRect(pos.x - 20, pos.y - h - 10, 40 * healthPercent, 5)
		}
		ctx.restore()
	}
	update(dt) {
		if (this.type === 'enemy') {
			const dist = Math.hypot(player.x - this.x, player.y - this.y)
			if (dist < 5 && dist > 0.8) {
				const dx = (player.x - this.x) / dist
				const dy = (player.y - this.y) / dist
				this.x += dx * 1.5 * dt / 1000
				this.y += dy * 1.5 * dt / 1000
			} else if (dist <= 0.8) {
				if (!this.attackCooldown || this.attackCooldown <= 0) {
					player.stats.health = Math.max(0, player.stats.health - 5)
					this.attackCooldown = 1000
				}
			}
			if (this.attackCooldown > 0) this.attackCooldown -= dt
		}
	}
	getSortY() {
		return this.x + this.y
	}
}
function generateWorld() {
	for (let y = 0; y < WORLD_HEIGHT; y++) {
		game.tiles[y] = []
		for (let x = 0; x < WORLD_WIDTH; x++) {
			const noise = Math.sin(x * 0.3) * Math.cos(y * 0.3) + Math.random() * 0.5
			game.tiles[y][x] = noise > 0.3 ? 'grass' : 'dirt'
		}
	}
	for (let i = 0; i < 40; i++) {
		const x = Math.random() * (WORLD_WIDTH - 4) + 2
		const y = Math.random() * (WORLD_HEIGHT - 4) + 2
		game.entities.push(new Entity(x, y, 'tree'))
	}
	for (let i = 0; i < 25; i++) {
		const x = Math.random() * (WORLD_WIDTH - 4) + 2
		const y = Math.random() * (WORLD_HEIGHT - 4) + 2
		game.entities.push(new Entity(x, y, 'rock'))
	}
	for (let i = 0; i < 20; i++) {
		const x = Math.random() * (WORLD_WIDTH - 4) + 2
		const y = Math.random() * (WORLD_HEIGHT - 4) + 2
		game.entities.push(new Entity(x, y, 'bush'))
	}
	for (let i = 0; i < 50; i++) {
		const x = Math.random() * (WORLD_WIDTH - 4) + 2
		const y = Math.random() * (WORLD_HEIGHT - 4) + 2
		game.entities.push(new Entity(x, y, 'grass'))
	}
	for (let i = 0; i < 6; i++) {
		const x = Math.random() * (WORLD_WIDTH - 4) + 2
		const y = Math.random() * (WORLD_HEIGHT - 4) + 2
		game.entities.push(new Entity(x, y, 'enemy'))
	}
}
function loadMapPack(uint8) {
	const mapData = extractTextChunk(uint8, 'mapData')
	if (!mapData) return false
	try {
		const data = JSON.parse(mapData)
		game.tiles = []
		game.tileData.clear()
		if (data.mapBounds) game.mapBounds = data.mapBounds
		if (data.tileData) {
			Object.entries(data.tileData).forEach(([key, tile]) => {
				game.tileData.set(key, tile)
			})
		}
		const terrainLayer = data.layers.find(l => l.type === 'terrain')
		if (terrainLayer) {
			for (let y = 0; y < data.mapSize.height; y++) {
				game.tiles[y] = []
				for (let x = 0; x < data.mapSize.width; x++) {
					game.tiles[y][x] = terrainLayer.data[y]?.[x] || 'grass'
				}
			}
		}
		game.entities = []
		if (data.entities) {
			data.entities.forEach(e => {
				const typeMap = {
					'tree': 'tree', 'rock': 'rock', 'bush': 'bush', 'grass': 'grass',
					'enemy_slime': 'enemy', 'enemy_skeleton': 'enemy',
					'npc_villager': 'enemy', 'npc_merchant': 'enemy',
					'chest': 'bush', 'fence': 'tree', 'house': 'tree'
				}
				const entityType = typeMap[e.type] || 'tree'
				const entity = new Entity(e.x, e.y, entityType)
				if (e.health) entity.health = e.health
				game.entities.push(entity)
			})
		}
		game.triggers = data.triggers || []
		return true
	} catch (err) {
		console.error('Map load error:', err)
		return false
	}
}
function extractTextChunk(uint8, keyword) {
	let i = 8
	while (i < uint8.length) {
		const length = (uint8[i] << 24) | (uint8[i+1] << 16) | (uint8[i+2] << 8) | uint8[i+3]
		const type = String.fromCharCode(uint8[i+4], uint8[i+5], uint8[i+6], uint8[i+7])
		if (type === 'tEXt') {
			const data = uint8.slice(i + 8, i + 8 + length)
			let nullIndex = 0
			for (let j = 0; j < data.length; j++) {
				if (data[j] === 0) { nullIndex = j; break }
			}
			const key = new TextDecoder().decode(data.slice(0, nullIndex))
			if (key === keyword) {
				return new TextDecoder().decode(data.slice(nullIndex + 1))
			}
		}
		i += 12 + length
	}
	return null
}
function getTileAt(x, y) {
	return game.tileData.get(`${Math.floor(x)},${Math.floor(y)}`) || null
}
function getGroundHeight(x, y, currentZ) {
	const tile = getTileAt(x, y)
	if (!tile) return 0
	if (tile.isBridge) {
		const bridgeBottom = tile.z - tile.thickness
		const bridgeTop = tile.z
		if (currentZ >= bridgeBottom - 0.1 && currentZ <= bridgeTop + 1) return bridgeTop
		if (currentZ < bridgeBottom - 0.1) return 0
	}
	if (tile.isSlope) {
		const tx = x - Math.floor(x)
		const ty = y - Math.floor(y)
		let t = 0
		if (tile.slopeDirection === 'x') t = tx
		else if (tile.slopeDirection === 'y') t = ty
		else t = (tx + ty) / 2
		return tile.slopeStart + (tile.slopeEnd - tile.slopeStart) * t
	}
	return tile.z || 0
}
function canPlayerPass(x, y, z, height) {
	const tile = getTileAt(x, y)
	if (!tile) return true
	const groundZ = getGroundHeight(x, y, z)
	if (tile.isBridge) {
		const bridgeBottom = tile.z - tile.thickness
		const bridgeTop = tile.z
		const playerTop = z + height
		if (z >= bridgeTop) return true
		if (playerTop <= bridgeBottom) return true
		if (z >= bridgeBottom - 0.1 && z <= bridgeTop + 0.5) return true
		return false
	}
	const headroom = 999
	return height <= headroom
}
function checkMovementCollision(newX, newY, newZ) {
	const halfW = player.physWidth / 2
	const halfD = player.physDepth / 2
	const corners = [
		{ x: newX - halfW, y: newY - halfD },
		{ x: newX + halfW, y: newY - halfD },
		{ x: newX - halfW, y: newY + halfD },
		{ x: newX + halfW, y: newY + halfD }
	]
	for (const corner of corners) {
		if (!canPlayerPass(corner.x, corner.y, newZ, player.currentHeight)) return false
	}
	return true
}
function updatePlayer(dt) {
	const wantCrouch = game.keys['ControlLeft'] || game.keys['ControlRight']
	const wantSprint = game.keys['ShiftLeft'] || game.keys['ShiftRight']
	if (wantCrouch && !player.isCrouching) {
		player.isCrouching = true
		player.currentHeight = player.crouchHeight
		player.isSprinting = false
	} else if (!wantCrouch && player.isCrouching) {
		const canStand = checkMovementCollision(player.x, player.y, player.z)
		if (canStand) {
			player.isCrouching = false
			player.currentHeight = player.standingHeight
		}
	}
	if (wantSprint && !player.isCrouching) player.isSprinting = true
	else if (!wantSprint || player.isCrouching) player.isSprinting = false
	let dx = 0, dy = 0
	if (game.keys['KeyW'] || game.keys['ArrowUp']) { dx -= 1; dy -= 1; player.direction = 'up' }
	if (game.keys['KeyS'] || game.keys['ArrowDown']) { dx += 1; dy += 1; player.direction = 'down' }
	if (game.keys['KeyA'] || game.keys['ArrowLeft']) { dx -= 1; dy += 1; player.direction = 'left' }
	if (game.keys['KeyD'] || game.keys['ArrowRight']) { dx += 1; dy -= 1; player.direction = 'right' }
	if (dx !== 0 || dy !== 0) {
		const len = Math.hypot(dx, dy)
		dx /= len
		dy /= len
	}
	player.isMoving = dx !== 0 || dy !== 0
	let speedMult = 1
	if (player.isSprinting) speedMult = player.sprintMultiplier
	else if (player.isCrouching) speedMult = player.crouchMultiplier
	const newX = player.x + dx * player.speed * speedMult * dt / 1000
	const newY = player.y + dy * player.speed * speedMult * dt / 1000
	const newZ = getGroundHeight(newX, newY, player.z)
	if (checkMovementCollision(newX, newY, newZ)) {
		player.x = Math.max(game.mapBounds.minX, Math.min(game.mapBounds.maxX, newX))
		player.y = Math.max(game.mapBounds.minY, Math.min(game.mapBounds.maxY, newY))
		player.z = newZ
	}
	if (player.isMoving) {
		player.frameTime += dt
		if (player.frameTime > 150) {
			player.frame = (player.frame + 1) % 4
			player.frameTime = 0
		}
	} else {
		player.frame = 0
	}
}
function updateCamera() {
	const targetX = (player.x - player.y) * (TILE_W / 2)
	const targetY = (player.x + player.y) * (TILE_H / 2)
	game.camera.x = targetX
	game.camera.y = targetY
}
function updateStats(dt) {
	player.stats.mana = Math.min(player.stats.maxMana, player.stats.mana + dt / 1000 * 2)
	player.stats.health = Math.max(0, Math.min(player.stats.maxHealth, player.stats.health))
}
function updateTime(dt) {
	game.time += dt
	const newDay = Math.floor(game.time / game.dayLength) + 1
	if (newDay !== game.day) game.day = newDay
}
function addExp(amount) {
	player.stats.exp += amount
	while (player.stats.exp >= player.stats.maxExp) {
		player.stats.exp -= player.stats.maxExp
		player.stats.level++
		player.stats.maxExp = Math.floor(player.stats.maxExp * 1.5)
		player.stats.maxHealth += 10
		player.stats.health = player.stats.maxHealth
		player.stats.maxMana += 10
		player.stats.mana = player.stats.maxMana
	}
}
function drawPlaceholder(x, y, w, h, label) {
	ctx.fillStyle = '#fff'
	ctx.fillRect(x - w/2, y - h, w, h)
	ctx.strokeStyle = '#c00'
	ctx.lineWidth = 2
	ctx.setLineDash([4, 2])
	ctx.strokeRect(x - w/2, y - h, w, h)
	ctx.setLineDash([])
	ctx.fillStyle = '#c00'
	ctx.font = 'bold 10px system-ui'
	ctx.textAlign = 'center'
	ctx.textBaseline = 'middle'
	ctx.fillText(label, x, y - h/2)
}
function drawIsometricTile(x, y, color) {
	const pos = worldToScreen(x, y)
	ctx.fillStyle = color
	ctx.beginPath()
	ctx.moveTo(pos.x, pos.y - TILE_H / 2)
	ctx.lineTo(pos.x + TILE_W / 2, pos.y)
	ctx.lineTo(pos.x, pos.y + TILE_H / 2)
	ctx.lineTo(pos.x - TILE_W / 2, pos.y)
	ctx.closePath()
	ctx.fill()
}
function renderTiles() {
	for (let y = 0; y < WORLD_HEIGHT; y++) {
		for (let x = 0; x < WORLD_WIDTH; x++) {
			const tile = game.tiles[y]?.[x] || 'grass'
			const baseColor = TERRAIN_COLORS[tile] || '#4a7c23'
			const variation = ((x + y) % 2 === 0) ? 0 : 10
			const r = parseInt(baseColor.slice(1, 3), 16) + variation
			const g = parseInt(baseColor.slice(3, 5), 16) + variation
			const b = parseInt(baseColor.slice(5, 7), 16) + variation
			drawIsometricTile(x, y, `rgb(${r},${g},${b})`)
		}
	}
}
function renderPlayer() {
	const pos = worldToScreen(player.x, player.y)
	ctx.save()
	ctx.fillStyle = 'rgba(0,0,0,0.2)'
	ctx.beginPath()
	ctx.ellipse(pos.x, pos.y + 5, 15, 8, 0, 0, Math.PI * 2)
	ctx.fill()
	ctx.globalAlpha = 1
	const bobOffset = player.isMoving ? Math.sin(Date.now() / 100) * 3 : 0
	drawPlaceholder(pos.x, pos.y - 20 + bobOffset, 30, 45, 'PLAYER')
	const selectedItem = player.quickBar[player.selectedSlot]
	if (selectedItem) {
		const toolOffset = player.direction === 'left' ? -20 : 20
		drawPlaceholder(pos.x + toolOffset, pos.y - 35, 16, 20, ITEMS[selectedItem.id].label.slice(0, 3))
	}
	ctx.restore()
}
function renderEntities() {
	const playerEntity = { x: player.x, y: player.y, isPlayer: true, getSortY: () => player.x + player.y }
	const sortable = [...game.entities, playerEntity]
	sortable.sort((a, b) => a.getSortY() - b.getSortY())
	sortable.forEach(e => {
		if (e.isPlayer) renderPlayer()
		else e.render(ctx)
	})
}
function renderDayNight() {
	const timeOfDay = (game.time % game.dayLength) / game.dayLength
	let alpha = 0
	if (timeOfDay > 0.7) alpha = (timeOfDay - 0.7) / 0.1
	else if (timeOfDay < 0.2) alpha = 1 - timeOfDay / 0.2
	alpha = Math.min(0.6, alpha)
	if (alpha > 0) {
		ctx.fillStyle = `rgba(10, 10, 40, ${alpha})`
		ctx.fillRect(0, 0, canvas.width, canvas.height)
	}
}
function render() {
	ctx.fillStyle = '#1a1a2e'
	ctx.fillRect(0, 0, canvas.width, canvas.height)
	renderTiles()
	renderEntities()
	renderDayNight()
}
function updateUI() {
	const healthPct = (player.stats.health / player.stats.maxHealth) * 100
	const manaPct = (player.stats.mana / player.stats.maxMana) * 100
	const expPct = (player.stats.exp / player.stats.maxExp) * 100
	document.querySelector('#health .stat-fill').style.width = healthPct + '%'
	document.querySelector('#health .stat-label span').textContent = `${Math.floor(player.stats.health)}/${player.stats.maxHealth}`
	document.querySelector('#mana .stat-fill').style.width = manaPct + '%'
	document.querySelector('#mana .stat-label span').textContent = `${Math.floor(player.stats.mana)}/${player.stats.maxMana}`
	document.querySelector('#exp .stat-fill').style.width = expPct + '%'
	document.querySelector('#exp .stat-label span').textContent = `${player.stats.exp}/${player.stats.maxExp}`
	document.getElementById('levelDisplay').textContent = `Lv.${player.stats.level}`
	const quickBar = document.getElementById('quickBar')
	quickBar.innerHTML = ''
	for (let i = 0; i < 6; i++) {
		const slot = document.createElement('div')
		slot.className = 'quick-slot' + (i === player.selectedSlot ? ' selected' : '')
		const item = player.quickBar[i]
		slot.innerHTML = `<span class="slot-key">${i + 1}</span>`
		if (item) {
			slot.innerHTML += `<div class="placeholder">${ITEMS[item.id].label}</div><span class="slot-count">${item.count > 1 ? item.count : ''}</span>`
		}
		quickBar.appendChild(slot)
	}
	const timeOfDay = (game.time % game.dayLength) / game.dayLength
	const isNight = timeOfDay > 0.7 || timeOfDay < 0.2
	document.getElementById('timeDisplay').textContent = `Day ${game.day} ${isNight ? 'Night' : 'Day'}`
}
function updateInventoryPanel() {
	const grid = document.getElementById('inventoryGrid')
	grid.innerHTML = ''
	for (let i = 0; i < 24; i++) {
		const slot = document.createElement('div')
		slot.className = 'inv-slot'
		const item = player.inventory[i]
		if (item) {
			slot.innerHTML = `<div class="placeholder">${ITEMS[item.id].label}</div><span class="slot-count">${item.count > 1 ? item.count : ''}</span>`
		}
		slot.onclick = () => {
			if (player.inventory[i]) {
				const emptyQuick = player.quickBar.findIndex(s => s === null)
				if (emptyQuick !== -1) {
					player.quickBar[emptyQuick] = player.inventory[i]
					player.inventory[i] = null
					updateInventoryPanel()
					updateUI()
				}
			}
		}
		grid.appendChild(slot)
	}
}
function updateStoragePanel() {
	const grid = document.getElementById('storageGrid')
	grid.innerHTML = ''
	for (let i = 0; i < 24; i++) {
		const slot = document.createElement('div')
		slot.className = 'inv-slot'
		const item = storage.items[i]
		if (item) {
			slot.innerHTML = `<div class="placeholder">${ITEMS[item.id].label}</div><span class="slot-count">${item.count > 1 ? item.count : ''}</span>`
		}
		slot.onclick = () => {
			if (storage.items[i]) {
				if (addItemToInventory(storage.items[i].id, storage.items[i].count)) {
					storage.items[i] = null
					updateStoragePanel()
					updateUI()
				}
			}
		}
		grid.appendChild(slot)
	}
}
function toggleInventory() {
	game.showInventory = !game.showInventory
	game.showStorage = false
	document.getElementById('inventoryPanel').style.display = game.showInventory ? 'block' : 'none'
	document.getElementById('storagePanel').style.display = 'none'
	if (game.showInventory) updateInventoryPanel()
}
function toggleStorage() {
	game.showStorage = !game.showStorage
	game.showInventory = false
	document.getElementById('storagePanel').style.display = game.showStorage ? 'block' : 'none'
	document.getElementById('inventoryPanel').style.display = 'none'
	if (game.showStorage) updateStoragePanel()
}
function addItemToQuickBar(itemId, count = 1) {
	const itemDef = ITEMS[itemId]
	if (itemDef.stackable) {
		const existing = player.quickBar.find(s => s && s.id === itemId)
		if (existing) {
			existing.count += count
			return true
		}
	}
	const emptySlot = player.quickBar.findIndex(s => s === null)
	if (emptySlot !== -1) {
		player.quickBar[emptySlot] = { id: itemId, count }
		return true
	}
	return addItemToInventory(itemId, count)
}
function addItemToInventory(itemId, count = 1) {
	const itemDef = ITEMS[itemId]
	if (itemDef.stackable) {
		const existing = player.inventory.find(s => s && s.id === itemId)
		if (existing) {
			existing.count += count
			return true
		}
	}
	const emptySlot = player.inventory.findIndex(s => s === null)
	if (emptySlot !== -1) {
		player.inventory[emptySlot] = { id: itemId, count }
		return true
	}
	return false
}
function interact() {
	const interactRange = 1.5
	const nearest = game.entities
		.filter(e => Math.hypot(e.x - player.x, e.y - player.y) < interactRange)
		.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y))[0]
	if (!nearest) return
	const requiredTool = nearest.getRequiredTool()
	const selectedItem = player.quickBar[player.selectedSlot]
	const hasTool = selectedItem && ITEMS[selectedItem.id].tool === requiredTool
	const hasWeapon = selectedItem && ITEMS[selectedItem.id].weapon
	let damage = 1
	if (requiredTool && hasTool) damage = 3
	if (nearest.type === 'enemy' && hasWeapon) damage = ITEMS[selectedItem.id].damage
	nearest.health -= damage
	if (nearest.health <= 0) {
		nearest.getDrops().forEach(drop => addItemToQuickBar(drop.item, drop.count))
		if (nearest.type === 'enemy') addExp(20)
		else addExp(5)
		game.entities = game.entities.filter(e => e !== nearest)
	}
}
document.getElementById('btnInventory').onclick = toggleInventory
document.getElementById('btnStorage').onclick = toggleStorage
document.getElementById('closeInventory').onclick = toggleInventory
document.getElementById('closeStorage').onclick = toggleStorage
document.addEventListener('keydown', e => {
	game.keys[e.code] = true
	if (e.code === 'Space') {
		interact()
		e.preventDefault()
	}
	if (e.code === 'KeyB') toggleInventory()
	if (e.code === 'KeyV') toggleStorage()
	if (e.code >= 'Digit1' && e.code <= 'Digit6') {
		player.selectedSlot = parseInt(e.code.charAt(5)) - 1
	}
})
document.addEventListener('keyup', e => {
	game.keys[e.code] = false
})
let lastTime = 0
function gameLoop(timestamp) {
	const dt = Math.min(timestamp - lastTime, 100)
	lastTime = timestamp
	if (!game.showInventory && !game.showStorage) {
		updatePlayer(dt)
		game.entities.forEach(e => e.update && e.update(dt))
	}
	updateCamera()
	updateStats(dt)
	updateTime(dt)
	render()
	updateUI()
	if (player.stats.health <= 0) {
		ctx.fillStyle = 'rgba(0,0,0,0.8)'
		ctx.fillRect(0, 0, canvas.width, canvas.height)
		ctx.fillStyle = '#e74c3c'
		ctx.font = '48px serif'
		ctx.textAlign = 'center'
		ctx.fillText('Game Over', canvas.width/2, canvas.height/2)
		ctx.font = '20px serif'
		ctx.fillStyle = 'white'
		ctx.fillText('刷新页面重新开始', canvas.width/2, canvas.height/2 + 40)
		return
	}
	requestAnimationFrame(gameLoop)
}
async function initGame() {
	const urlParams = new URLSearchParams(window.location.search)
	const mapUrl = urlParams.get('map')
	let mapLoaded = false
	if (mapUrl) {
		try {
			const response = await fetch(mapUrl)
			const arrayBuffer = await response.arrayBuffer()
			const uint8 = new Uint8Array(arrayBuffer)
			mapLoaded = loadMapPack(uint8)
		} catch (err) {
			console.error('Failed to load map:', err)
		}
	}
	if (!mapLoaded) {
		generateWorld()
	}
	addItemToQuickBar('wood', 5)
	addItemToQuickBar('stone', 3)
	addItemToQuickBar('sword', 1)
	requestAnimationFrame(gameLoop)
}
initGame()
	</script>
</body>
</html>
